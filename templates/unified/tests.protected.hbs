import { test, expect } from '@playwright/test';
import { testConfig } from '../config/test-config.js';
import { protectedRoutes } from '../routes/protected-routes.js';
import { isRedirectedToLogin } from '../helpers/redirect-helper.js';
{{#ifFramework "shopify-app"}}
import { isShopifyAuthRedirect, checkShopifyAppBridge } from '../helpers/shopify-auth-helper.js';
{{/ifFramework}}

test.describe('Protected Routes - Authentication Redirect Testing', () => {
  test.beforeEach(async ({ page }) => {
    test.setTimeout(testConfig.timeout);
  });

  // Iterate through all protected routes from JSON file
  protectedRoutes.forEach(({ url, title, expectedRedirect, keyElement, timeout }) => {
    test(`${title || `Route ${url}`} should redirect to login when not authenticated`, async ({ page }) => {
      // Set custom timeout if specified for this route
      if (timeout) {
        test.setTimeout(timeout);
      }
      
      console.log(`ðŸ” Testing protected route: ${url}`);
      
      // Attempt to access protected route without authentication
      const response = await page.goto(`${testConfig.baseURL}${url}`);
      
      // Wait for any redirects to complete
      await page.waitForLoadState('networkidle');
      
      const currentUrl = page.url();
      
      // Check if redirected to login
      {{#ifFramework "shopify-app"}}
      const redirectedToLogin = await isShopifyAuthRedirect(page, testConfig.loginURL);
      {{else}}
      const redirectedToLogin = await isRedirectedToLogin(page, testConfig.loginURL);
      {{/ifFramework}}
      
      expect(redirectedToLogin).toBe(true);
      
      // Verify we're actually on a login page
      const isLoginPage = await page.evaluate(() => {
        const bodyText = document.body.textContent?.toLowerCase() || '';
        const hasLoginText = bodyText.includes('login') || 
                           bodyText.includes('sign in') || 
                           bodyText.includes('authenticate');
        
        const hasPasswordField = document.querySelector('input[type="password"]') !== null ||
                               document.querySelector('input[name="password"]') !== null ||
                               document.querySelector('[data-testid="password"]') !== null;
        
        return hasLoginText || hasPasswordField;
      });
      
      expect(isLoginPage).toBe(true);
      
      // Check for key elements on login page if specified (can be null)
      if (keyElement) {
        try {
          await expect(page.locator(keyElement)).toBeVisible({ timeout: 10000 });
          console.log(`âœ… Key element found on login page: ${keyElement}`);
        } catch (error) {
          console.warn(`âš ï¸ Key element not found on login page: ${keyElement}`);
          // Don't fail the test - just log the warning
        }
      }
      
      {{#ifFramework "nextjs"}}
      // Next.js specific authentication checks
      await expect(page.locator('body')).not.toHaveText(/404|Not Found/i);
      await expect(page.locator('body')).not.toHaveText(/Application error/i);
      {{/ifFramework}}
      
      {{#ifFramework "express"}}
      // Express specific checks - might return 401 or redirect
      if (response?.status() === 401) {
        console.log(`ðŸ”’ ${title || `Route ${url}`} returned 401 Unauthorized (API-style protection)`);
      }
      {{/ifFramework}}
      
      console.log(`âœ… ${title || `Route ${url}`} properly protected - redirected to: ${currentUrl}`);
    });
  });
  
  test.afterAll(async () => {
    const protectedCount = protectedRoutes.length;
    console.log(`ðŸ“Š Security Summary: Tested ${protectedCount} protected routes`);
    console.log(`ðŸ”’ All routes properly redirect unauthorized users to login`);
  });
});